Одна из основных функций ROS - организация распределенной архитектуры ПО. Т.е. множество программ должны объединяться в одну систему. Поэтому далее задания на все виды ROS интерфейсов 

1) Топик:
Реализовать паблишера и подписчика. Паблишер публикует текущее время. Подписчик получает его и выводит в лог
После запустить ещё одного подписчика

2) Сервис:
Написать msg с константами: NOW = 0, DEFERRED = 1
Написать srv: в запросе поле с одной из констант и поле float duration, в ответе bool success, string message (описание ошибки)

Реализовать логику сервера:
Если NOW, то сервис должен возвращать немедленно успех
Если DEFERRED, то нужно заснуть на duration секунд.
При этом DEFERRED < 1 считается ошибкой

Клиент просто запускается, вызывает сервис с разными вариантами полей запроса, выводит ответ в лог.

3) Экшн
int32 target_position
float duration
---
std_msgs/Header header                # заголовок сообщения
string message                        # сообщение, если произошла ошибка
---
int32 position
Клиент кидает запрос с целевой позицией и временем движения в неё. 

У сервера конфигурируемый параметр (через ROS parameter) - частота выполнения.
Сервер принимает запрос и начинает двигаться из текущей позиции в целевую с дискретностью, зависящей от частоты выполнения. Тут нужно будет исходя из поля duration (которое в секундах) рассчитать шаг инкремента. Каждый шаг отчитываться в feedback о текущей позиции

Итого:
В п.1 реализуешь широковещательные сообщения
В п.2 реализуешь взаимодействие одного к одному
В п.3 реализуешь вариант длительного действия